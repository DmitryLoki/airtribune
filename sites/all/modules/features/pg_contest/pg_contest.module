<?php
/**
 * @file
 * Code for the Paragliding Contest feature.
 * Custom implementation of hooks for paragliding contest content type
 */

include_once 'pg_contest.features.inc';

/**
 * Implementation of hook_form
 * Default base is 'node_content'
 * @param type $node
 * @param type $form_state
 */
function pg_contest_form($node, $form_state) {
  //Default base is 'node_content'
  //Title field is not attached otherwise
  $form = node_content_form($node, $form_state);
  return $form;
}

/* Implementation of hook_presave
 * @param type $node
 * @author Alexandr Kapelshikov <alex2cpw@gmail.com>
 */
function pg_contest_node_presave($node) {
  
  // Pathauto and path modules should never execute for events by themselves
  if ($node->type == AIRTRIBUNE_PG_CONTEST_TYPE) {
    // Note that $node->path is empty if node is loaded/saved programmatically
    // since it is added in form_alter (see path.module)
    
    // In case node is processed programmatically
    if (!empty($node->nid) && !isset($node->path)) {
      $conditions = array('source' => 'event/' . $node->nid);
      $path = pg_contest_path_load($conditions);
      if (!empty($path)) {
        $node->event_path = $path;
      }
    }
    // In case node is edited through node form
    elseif (isset($node->path)) {
      // Store path alias settings for further processing.
      $node->event_path = $node->path;
    }
    
    // We don't want path and pathauto module take any action for event nodes, i.e. to create node alias.
    
    // Set pathauto to FALSE to avoid pathauto_node_update_alias() processing.
    // Clear $node->path['alias'] to avoid path_node_insert() processing.
    // Remove all other path data since we don't need it any more.
    $node->path = array('pathauto' => FALSE, 'alias' => '',);
  }
}

/**
 * Implements hook_form_node_form_alter().
 * 
 * Set default path alias values for node form.
 * TODO: Make sure that this is always fired after path_form_node_form_alter().
 */
function pg_contest_form_node_form_alter(&$form, $form_state) {
  if (!empty($form['#node']->nid)) {
    $conditions = array('source' => 'event/' . $form['#node']->nid);
    $path = pg_contest_path_load($conditions);
    if (!empty($path)) {
      $form['path']['#collapsed'] = empty($path['alias']);
      $form['path']['alias']['#default_value'] = $path['alias'];
      $form['path']['pid']['#value'] = $path['pid'];
      $form['path']['source']['#value'] = $path['source'];
      $form['path']['language']['#value'] = $path['language'];
    }
  }
}

/**
 * Fetch a specific URL alias from the database.
 *
 * @see path_load()
 * @see http://drupal.org/node/1160764
 */
function pg_contest_path_load($conditions) {
  if (is_numeric($conditions)) {
    $conditions = array('pid' => $conditions);
  }
  elseif (is_string($conditions)) {
    $conditions = array('source' => $conditions);
  }
  elseif (!is_array($conditions)) {
    return FALSE;
  }
  $select = db_select('url_alias');
  foreach ($conditions as $field => $value) {
    $select->condition($field, $value);
  }
  return $select
    ->fields('url_alias')
    ->orderBy('pid', 'DESC')
    ->execute()
    ->fetchAssoc();
}

/**
 * Implementation of hook_insert
 * @param $node
 * The node that is being created.
 */
function pg_contest_insert($node) {
  if (isset($node->field_points_file[LANGUAGE_NONE][0])) {
    pg_contest_create_points($node->field_points_file[LANGUAGE_NONE][0], $node->nid);
  }
  
  // Create aliases
  _pg_contest_create_alias($node);
  // Restrict subscription depending on Registration Switch field.
  _pg_contest_og_registration_perm($node);
}
 
/* Implementation of hook_update
 * @param type $node
 * @see og_membership_delete_by_group()
 * @author Vadim Valuev <gease@mail.ru>
 */
function pg_contest_update($node) {
  // Points file check
  if (!empty($node->field_points_file[LANGUAGE_NONE][0]['fid'])) {
    // Check for update file
    if (!empty($node->original->field_points_file[LANGUAGE_NONE][0]['fid']) && 
          $node->field_points_file[LANGUAGE_NONE][0]['fid'] == $node->original->field_points_file[LANGUAGE_NONE][0]['fid']) {
      // Do nothing
    } else {
      //remove old points 
      $query = new EntityFieldQuery();
      $result = $query 
        ->entityCondition('entity_type', 'ent_contest_point')
        ->fieldCondition(OG_AUDIENCE_FIELD, 'target_id', $node->nid)
        ->execute();
      if (!empty($result['ent_contest_point'])) {
        entity_delete_multiple('ent_contest_point', array_keys($result['ent_contest_point']));
      }
    }
    if (isset($node->field_points_file[LANGUAGE_NONE])) {
      //create new points and subscribe them to group 
      pg_contest_create_points($node->field_points_file[LANGUAGE_NONE][0]['fid'], $node->nid);
    }
  }
  
  // Create aliases
  _pg_contest_create_alias($node);
  // Restrict subscription depending on Registration Switch field.
  _pg_contest_og_registration_perm($node);
}

/**
 * Implementation of hook_delete
 * @param $node
 *   The node that is being deleted.
 */
function pg_contest_delete($node) {
  // Delete aliases
  _pg_contest_delete_alias($node);
}

/**
 * Implementation of hook_validate
 * @author Vadim Valuev <gease@mail.ru>
 */
function pg_contest_validate($node, $form, &$form_state) {
  // Points file check
  if (!empty($node->field_points_file[LANGUAGE_NONE][0]['fid'])) {
    // Check for update file
    if (!empty($form_state['node']->field_points_file[LANGUAGE_NONE][0]['fid']) && 
          $node->field_points_file[LANGUAGE_NONE][0]['fid'] == $form_state['node']->field_points_file[LANGUAGE_NONE][0]['fid']) {
      // Do nothing
    } else {
      $file = file_load($node->field_points_file[LANGUAGE_NONE][0]['fid']);
      $file_string = file_get_contents($file->uri);
      $strings = preg_split('/\v/', $file_string);
      foreach ($strings as $string) {
        $elements = preg_split('/\s+/', $string);
        if ($elements[0] == 'G') {
          array_shift($elements);
          $datum = strtoupper(implode($elements));
          if ($datum != 'WGS84') {
            form_set_error('field_points_file', t('Incorrect datum'));
          }
        }
        if ($elements[0] == 'U') {
          if ($elements[1] != 1) {
            form_set_error('field_points_file', t('Cordinates should be Lat/Lon'));
          }
          else {
            $u = TRUE;
          }
        }
      }
      if (!isset($datum)) {
        form_set_error('field_points_file', t('Datum not set'));
      }
      if (!isset($u)) {
        form_set_error('field_points_file', t('Coordinate system not set'));
      }
    }
  }
}

/**
 * Parse file and create point entities 
 * @author Vadim Valuev <gease@mail.ru>
 */
function pg_contest_create_points($fid, $nid) {
  geophp_load();
  $file = file_load($fid);
  $file_string = file_get_contents($file->uri);
  $strings = preg_split('/\v/', $file_string);
  foreach ($strings as $string) {
    $elements = preg_split('/\s+/', $string);
    if ($elements[0] != 'W') continue;
    $let1 = substr($elements[3], -1);
    $let2 = substr($elements[4], -1);
    if (strpos('EW', $let1) !== FALSE && strpos('NS', $let2) !== FALSE) {
      $lon = ($let1 == 'E') ? floatval($elements[3]) : -floatval($elements[3]);
      $lat = ($let2 == 'N') ? floatval($elements[4]) : -floatval($elements[4]);
    }
    elseif (strpos('EW', $let2) !== FALSE && strpos('NS', $let1) !== FALSE) {
      $lon = ($let2 == 'E') ? floatval($elements[4]) : -floatval($elements[4]);
      $lat = ($let1 == 'N') ? floatval($elements[3]) : -floatval($elements[3]);      
    }
    else {
      continue;
    }
    $coords = new Point($lon, $lat);
    //$values = geofield_get_values_from_geometry($coords);
    $values = array(
      'type' => 'contest_point',
      'language' => LANGUAGE_NONE,
      'title' => $elements[1],
      'field_point_location' => array(
        LANGUAGE_NONE  => array(
          0 => geofield_get_values_from_geometry($coords)
        )
      ),
      'field_point_description' => array(
        LANGUAGE_NONE  => array(
          0 => array('value' => isset($elements[8]) ? implode(' ', array_slice($elements, 8)) : '')
        ),
      ),
    );
    $point = entity_create('ent_contest_point', $values);
    $point->save();
    // linking to og should go to EntContestPointController 
    og_group('node', $nid, array('entity_type' => 'ent_contest_point', 'entity' => $point))->save();
  }
}

/**
 * Remove existing alises for path.
 *
 */
function _pg_contestant_path_delete($url) {
    $criteria = path_load($url);
    if (!empty($criteria)) {
      $criteria = array('source' => $criteria['source']);
      path_delete($criteria);
    }
}

/**
 * Initialize urls of pages 
 * @param $nid - node nid
 * @return array
 */
function _pg_contest_urls_init($nid) {
    $result = array();
    $result['url_base'] = "event/$nid";
    $result['url_pages'] = array(
        '/info',
        '/info/details',
        '/blog',
        '/pilots',
        '/pilots/status',
        '/pilots/manage',
        '/pilots/nation',
        '/map',
        '/map/accommodations',
        '/map/activities',
        '/map/basic',
        '/register',
        '/results',
    );
    return $result;
}

/**
 * Create contest alias.
 * @author Alexandr Kapelshikov
 */
function _pg_contest_create_alias($node) {
  module_load_include('inc', 'pathauto');
  if (function_exists('pathauto_cleanstring') && isset($node->nid) && !empty($node->title)) {
    $nid = $node->nid;
    
    // Check if alias is set manually.
    if (!empty($node->event_path['alias'])) {
      $alias_base = $node->event_path['alias'];
    }
    // Else try to get pathauto pattern.
    else {
      // See pathauto_node_update_alias().
      $options = array('language' => pathauto_entity_language('node', $node));
      
      // Skip processing if the node has no pattern.
      if (!pathauto_pattern_load_by_entity('node', $node->type, $options['language'])) {
        return;
      }
      
      module_load_include('inc', 'pathauto');
      $uri = entity_uri('node', $node);
      // Ask pathauto to return alias.
      $alias_base = pathauto_create_alias('node', 'return', $uri['path'], array('node' => $node), $node->type, $options['language']);
    }
    
    // Do nothing if there is no alias set (otherwise we may blow away existing aliases...)
    if (empty($alias_base)) {
      return;
    }

    $urls_init = _pg_contest_urls_init($node->nid);
    $url_base = $urls_init['url_base'];
    $url_pages = $urls_init['url_pages'];
    $aliases = array($alias_base => $url_base);
    
    // Remove existing alises.
    _pg_contestant_path_delete($url_base);
    foreach ($url_pages as $source) {
      $url_curr = $url_base . $source;  
      _pg_contestant_path_delete($url_curr);
      
      //Create aliases array
      $aliases[$alias_base . $source] = $url_curr;
    }

    // Save tiny aliases.
    $tiny_path_items = field_get_items('node', $node,  AIRTRIBUNE_TINY_PATH_FIELD);
    // Check that $tiny_path_items is not empty
    if (!empty($tiny_path_items) && is_array($tiny_path_items)) {
      foreach ($tiny_path_items as $tiny_path) {
        $path = array('source' => $url_base, 'alias' => $tiny_path['value']);
        path_save($path);
      }
    }

    // Save aliases.
    foreach ($aliases as $alias => $source) {
      $path = array('source' => $source, 'alias' => $alias);
      path_save($path);
    }


  }
}

/**
 * Delete contest alias.
 * @author Alexandr Kapelshikov
 */
function _pg_contest_delete_alias($node) {
  module_load_include('inc', 'pathauto');
  if (function_exists('pathauto_cleanstring') && isset($node->nid)) {
    $nid = $node->nid;
    $urls_init = _pg_contest_urls_init($node->nid);
    $url_base = $urls_init['url_base'];
    $url_pages = $urls_init['url_pages'];
    
    // Remove existing alises.
    _pg_contestant_path_delete($url_base);
    foreach ($url_pages as $source) {
      $url_curr = $url_base . $source;  
      _pg_contestant_path_delete($url_curr);
    }
  }
}

/**
 * Restrict OG registration.
 * @author Alexandr Kapelshikov <alex2cpw@gmail.com>
 */
function _pg_contest_og_registration_perm($node) {
  
  $entity_type = $group_type = 'node';
  $bundle = $node->type;
  $gid = $node->nid;
  
  
  if (!og_is_group_type($entity_type, $bundle)) {
    return;
  }
  
  // Do nothing if defaults are used.
  if (og_is_group_default_access($group_type, $gid)) {
    return;
  }
  
  // Get non-member role id.
  $og_roles = og_roles($group_type, $bundle, $gid);
  $nonmember_rid = array_search(OG_ANONYMOUS_ROLE, $og_roles);
  if ($nonmember_rid === FALSE) {
    return;
  }
  
  $grant = (isset($node->field_registration_sw['und'][0]['value']) && $node->field_registration_sw['und'][0]['value'] == 1)
         ? 1
         : 0;
  
  // Set permissions.
  $permissions = array('subscribe' => $grant, 'subscribe without approval' => $grant);
  og_role_change_permissions($nonmember_rid, $permissions);
}

/**
 * Implements hook_cron().
 */
function pg_contest_cron() {
  $now = time();
  $date = $now - 2 * 24 * 3600;
  
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'node');
  $query->entityCondition('bundle', 'pg_contest');
  $query->fieldCondition('field_dates', 'value', date("Y-m-d", $date), '<');
  $query->fieldCondition('field_dates', 'value2', date("Y-m-d", $now), '>=');
  $result = $query->execute();
  
  // Close registration for selected events.
  if (!empty($result['node'])) {
    foreach ($result['node'] as $nid => $date) {
      $node = node_load($nid);
      // if ($node->nid) {
      if ($node->nid && isset($node->field_registration_sw['und'][0]['value']) && $node->field_registration_sw['und'][0]['value'] !== 0) {
        $node->field_registration_sw['und'][0]['value'] = 0;
        node_save($node);
      }
    }
  }
}

/** 
 * Implementation of hook_field_access
 * Hide Registration switch field.
 * @author Alexandr Kapelshikov <alex2cpw@gmail.com>
 */
function pg_contest_field_access($op, $field, $entity_type, $entity, $account) {
  
  if ($op == 'edit' && $field['field_name'] == AIRTRIBUNE_REGISTRATION_SW_FIELD && !empty($entity->{AIRTRIBUNE_DATES_FIELD}['und'][0]['value']) && ($entity->type == AIRTRIBUNE_PG_CONTEST_TYPE)) {
    global $user;
    
    $date = time() - 2 * 24 * 3600;
    // Event start date.
    $value = strtotime($entity->{AIRTRIBUNE_DATES_FIELD}['und'][0]['value']);
    
    // For allowed roles switch is always shown.
    $allowed_roles = array('admin');
    $intersect = array_intersect($user->roles, $allowed_roles);
    
    // Hide registration switch
    if ($value < $date && empty($intersect)) {
      return FALSE;
    }
  }
}
