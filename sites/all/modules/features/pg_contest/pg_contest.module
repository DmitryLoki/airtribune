<?php
/**
 * @file
 * Code for the Paragliding Contest feature.
 * Custom implementation of hooks for paragliding contest content type
 */

include_once 'pg_contest.features.inc';

/**
 * Implementation of hook_form
 * Default base is 'node_content'
 * @param type $node
 * @param type $form_state
 */
function pg_contest_form($node, $form_state) {
  //Default base is 'node_content'
  //Title field is not attached otherwise
  $form = node_content_form($node, $form_state);
  return $form;
}

/* Implementation of hook_presave
 * @param type $node
 * @author Alexandr Kapelshikov <alex2cpw@gmail.com>
 */
function pg_contest_node_presave($node) {

  // Pathauto and path modules should never execute for events by themselves
  if ($node->type == AIRTRIBUNE_PG_CONTEST_TYPE) {
    // Note that $node->path is empty if node is loaded/saved programmatically
    // since it is added in form_alter (see path.module)

    // In case node is processed programmatically
    if (!empty($node->nid) && !isset($node->path)) {
      $conditions = array('source' => 'event/' . $node->nid);
      $path = pg_contest_path_load($conditions);
      if (!empty($path)) {
        $node->event_path = $path;
      }
    }
    // In case node is edited through node form
    elseif (isset($node->path)) {
      // Store path alias settings for further processing.
      $node->event_path = $node->path;
    }

    // We don't want path and pathauto module take any action for event nodes, i.e. to create node alias.

    // Set pathauto to FALSE to avoid pathauto_node_update_alias() processing.
    // Clear $node->path['alias'] to avoid path_node_insert() processing.
    // Remove all other path data since we don't need it any more.
    $node->path = array('pathauto' => FALSE, 'alias' => '',);
  }
}

/**
 * Implements hook_form_node_form_alter().
 */
function pg_contest_form_node_form_alter(&$form, $form_state, $form_id) {
  // Set default path alias values for node form.
  // TODO: Make sure that this is always fired after path_form_node_form_alter().
  if (!empty($form['#node']->nid)) {
    $conditions = array('source' => 'event/' . $form['#node']->nid);
    $path = pg_contest_path_load($conditions);
    if (!empty($path)) {
      $form['path']['#collapsed'] = empty($path['alias']);
      $form['path']['alias']['#default_value'] = $path['alias'];
      $form['path']['pid']['#value'] = $path['pid'];
      $form['path']['source']['#value'] = $path['source'];
      $form['path']['language']['#value'] = $path['language'];
    }
  }
}

/**
 * Implements hook_form_alter().
 */
function pg_contest_form_alter(&$form, $form_state, $form_id) {
  // Work with Flying Site (FS) and Take off basic marks (TO)
  // @see #3986
  if ($form_id == 'pg_contest_node_form' || $form_id == 'airtribune_event_settings_form' || $form_id == 'hg_contest_node_form') {
    $node = !empty($form['#node']) ? $form['#node'] : $form['#entity'];
    $wrapper = entity_metadata_wrapper('node', $node);
    // User edit contest node, field already have existing FS.
    $fs = $wrapper->field_flying_site_ref->raw();
    // User change option in FS select, FS was sended by AJAX-request.
    if (!empty($form_state['values']['field_flying_site_ref'])) {
      $fs = $form_state['values']['field_flying_site_ref']['und']['0']['target_id'];
    }
    // Some stuff for design.
    $email = l('Email us', 'mailto:' . variable_get('site_mail', ''), array('absolute' => TRUE));
    $form['field_flying_site_ref']['und']['#description'] = t("!email_us, if you don't see your place in the list.", array('!email_us' => $email));
    unset($form['field_take_offs']['und']['#title']);
    // Load TO for selected FS.
    if ($fs) {
      if ($take_offs = get_takeoffs_for_flyingsite($fs)) {
        $form['field_take_offs']['und']['#options'] = $take_offs;
        $fs_entity = node_load($fs);
        $fs_link = l($fs_entity->title, drupal_get_path_alias('node/' . $fs_entity->nid), array('absolute' => TRUE));
        $form['field_take_offs']['und']['#description'] = t('Choose official take off(s) for !fs_link flying site.', array('!fs_link' => $fs_link));
      }
      else {
        $form['field_take_offs']['und']['#options'] = array();
        $form['field_take_offs']['und']['#description'] = t('No take offs for this flying site.');
      }
      // If edit contest & have checked take offs - load its to element.
      $take_offs_checked = $wrapper->field_take_offs->raw();
      if ($take_offs_checked) {
        $form['field_take_offs']['und']['#default_value'] = $take_offs_checked;
      }
    }
    // New contest, hide any variants from default entityreference widget/formatter.
    else {
      $form['field_take_offs']['und']['#options'] = array();
    }
    // Add AJAX callback to FS field.
    $form['field_flying_site_ref']['und']['#ajax'] = array(
      'callback' => 'pg_contest_flyingsite_ajax_callback',
      'wrapper' => 'take-off-list',
      'method' => 'replace',
      'effect' => 'fade',
    );
    // Add wrapper to TO field. Will update this wrapper.
    $form['field_take_offs']['#weight'] = 30;
    $form['field_take_offs']['und']['#prefix'] = '<div id="take-off-list">';
    $form['field_take_offs']['und']['#suffix'] = '</div>';

    $no_yes = array(0 => t('No'), 1 => t('Yes'));
    $form['field_fs_is_defined'] = array(
      '#type' => 'radios',
      '#title' => t('Flying site is already defined'),
      '#options' => drupal_map_assoc($no_yes),
      '#weight' => $form['field_flying_info']['#weight']-5,
      '#default_value' => $no_yes[(bool) $wrapper->field_flying_site_ref->raw()],
    );

    $show_field_at_fs_defined = array(
      'visible' => array(':input[name="field_fs_is_defined"]' => array('value' => t('Yes')),),
      'invisible' => array(':input[name="field_fs_is_defined"]' => array('value' => t('No')),),
    );
    $hide_field_at_fs_defined = array(
      'visible' => array(':input[name="field_fs_is_defined"]' => array('value' => t('No')),),
      'invisible' => array(':input[name="field_fs_is_defined"]' => array('value' => t('Yes')),),
    );
    $form['field_take_offs']['#states'] = $show_field_at_fs_defined;
    $form['field_flying_site_ref']['#states'] = $show_field_at_fs_defined;
    $form['field_flying_info']['#states'] = $hide_field_at_fs_defined;
    $form['#after_build'][] = 'airtribune_node_form_after_build';
  }
}

function pg_contest_flyingsite_ajax_callback($form, $form_state) {
  return $form['field_take_offs'];
}


function airtribune_node_form_after_build($form) {
    // Hide format help for specific field
    $form['field_flying_info'][$form['field_flying_info']['#language']]['0']['format']['#access'] = FALSE;
    return $form;
}

/**
 * Fetch a specific URL alias from the database.
 *
 * @see path_load()
 * @see http://drupal.org/node/1160764
 */
function pg_contest_path_load($conditions) {
  if (is_numeric($conditions)) {
    $conditions = array('pid' => $conditions);
  }
  elseif (is_string($conditions)) {
    $conditions = array('source' => $conditions);
  }
  elseif (!is_array($conditions)) {
    return FALSE;
  }
  $select = db_select('url_alias');
  foreach ($conditions as $field => $value) {
    $select->condition($field, $value);
  }
  return $select
    ->fields('url_alias')
    ->orderBy('pid', 'DESC')
    ->execute()
    ->fetchAssoc();
}

/**
 * Implementation of hook_insert
 * @param $node
 * The node that is being created.
 */
function pg_contest_insert($node) {
  // Create aliases
  _pg_contest_create_alias($node);
  // Restrict subscription depending on Registration Switch field.
  _pg_contest_og_registration_perm($node);
}

/* Implementation of hook_update
 * @param type $node
 * @see og_membership_delete_by_group()
 * @author Vadim Valuev <gease@mail.ru>
 */
function pg_contest_update($node) {
  // Create aliases
  _pg_contest_create_alias($node);
  // Restrict subscription depending on Registration Switch field.
  _pg_contest_og_registration_perm($node);
}

/**
 * Implementation of hook_delete
 * @param $node
 *   The node that is being deleted.
 */
function pg_contest_delete($node) {
  // Delete aliases
  _pg_contest_delete_alias($node);
}

/**
 * Remove existing alises for path.
 *
 */
function _pg_contestant_path_delete($url) {
  $criteria = path_load($url);
  if (!empty($criteria)) {
    $criteria = array('source' => $criteria['source']);
    path_delete($criteria);
  }
}

/**
 * Initialize urls of pages
 * @param $nid - node nid
 * @return array
 */
function _pg_contest_urls_init($nid) {
  $result = array();
  $result['url_base'] = "event/$nid";
  $result['url_pages'] = array(
    '/info',
    '/info/details',
    '/blog',
    '/pilots',
    '/pilots/status',
    '/pilots/manage',
    '/pilots/nation',
    '/map',
    '/map/accommodations',
    '/map/activities',
    '/map/basic',
    '/register',
    '/results',
    '/settings',
  );
  return $result;
}

/**
 * Create contest alias.
 * @author Alexandr Kapelshikov
 */
function _pg_contest_create_alias($node) {
  module_load_include('inc', 'pathauto');
  if (function_exists('pathauto_cleanstring') && isset($node->nid) && !empty($node->title)) {
    $nid = $node->nid;

    // Check if alias is set manually.
    if (!empty($node->event_path['alias'])) {
      $alias_base = $node->event_path['alias'];
    }
    // Else try to get pathauto pattern.
    else {
      // See pathauto_node_update_alias().
      $options = array('language' => pathauto_entity_language('node', $node));

      // Skip processing if the node has no pattern.
      if (!pathauto_pattern_load_by_entity('node', $node->type, $options['language'])) {
        return;
      }

      module_load_include('inc', 'pathauto');
      $uri = entity_uri('node', $node);
      // Ask pathauto to return alias.
      $alias_base = pathauto_create_alias('node', 'return', $uri['path'], array('node' => $node), $node->type, $options['language']);
    }

    // Do nothing if there is no alias set (otherwise we may blow away existing aliases...)
    if (empty($alias_base)) {
      return;
    }

    $urls_init = _pg_contest_urls_init($node->nid);
    $url_base = $urls_init['url_base'];
    $url_pages = $urls_init['url_pages'];
    $aliases = array($alias_base => $url_base);

    // Remove existing alises.
    _pg_contestant_path_delete($url_base);
    foreach ($url_pages as $source) {
      $url_curr = $url_base . $source;
      _pg_contestant_path_delete($url_curr);

      //Create aliases array
      $aliases[$alias_base . $source] = $url_curr;
    }

    // Save tiny aliases.
    $tiny_path_items = field_get_items('node', $node, AIRTRIBUNE_TINY_PATH_FIELD);
    // Check that $tiny_path_items is not empty
    if (!empty($tiny_path_items) && is_array($tiny_path_items)) {
      foreach ($tiny_path_items as $tiny_path) {
        $path = array('source' => $url_base, 'alias' => $tiny_path['value']);
        path_save($path);
      }
    }

    // Save aliases.
    foreach ($aliases as $alias => $source) {
      $path = array('source' => $source, 'alias' => $alias);
      path_save($path);
    }


  }
}

/**
 * Delete contest alias.
 * @author Alexandr Kapelshikov
 */
function _pg_contest_delete_alias($node) {
  module_load_include('inc', 'pathauto');
  if (function_exists('pathauto_cleanstring') && isset($node->nid)) {
    $nid = $node->nid;
    $urls_init = _pg_contest_urls_init($node->nid);
    $url_base = $urls_init['url_base'];
    $url_pages = $urls_init['url_pages'];

    // Remove existing alises.
    _pg_contestant_path_delete($url_base);
    foreach ($url_pages as $source) {
      $url_curr = $url_base . $source;
      _pg_contestant_path_delete($url_curr);
    }
  }
}

/**
 * Restrict OG registration.
 * @author Alexandr Kapelshikov <alex2cpw@gmail.com>
 */
function _pg_contest_og_registration_perm($node) {

  $entity_type = $group_type = 'node';
  $bundle = $node->type;
  $gid = $node->nid;


  if (!og_is_group_type($entity_type, $bundle)) {
    return;
  }

  // Do nothing if defaults are used.
  if (og_is_group_default_access($group_type, $gid)) {
    return;
  }

  // Get non-member role id.
  $og_roles = og_roles($group_type, $bundle, $gid);
  $nonmember_rid = array_search(OG_ANONYMOUS_ROLE, $og_roles);
  if ($nonmember_rid === FALSE) {
    return;
  }

  $grant = (isset($node->field_registration_sw['und'][0]['value']) && $node->field_registration_sw['und'][0]['value'] == 1)
    ? 1
    : 0;

  // Set permissions.
  $permissions = array('subscribe' => $grant, 'subscribe without approval' => $grant);
  og_role_change_permissions($nonmember_rid, $permissions);
}

/**
 * Implements hook_cron().
 */
function pg_contest_cron() {
  $now = time();
  $date = $now - 2 * 24 * 3600;

  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'node');
  $query->entityCondition('bundle', 'pg_contest');
  $query->fieldCondition('field_dates', 'value', date("Y-m-d", $date), '<');
  $query->fieldCondition('field_dates', 'value2', date("Y-m-d", $now), '>=');
  $result = $query->execute();

  // Close registration for selected events.
  if (!empty($result['node'])) {
    foreach ($result['node'] as $nid => $date) {
      $node = node_load($nid);
      // if ($node->nid) {
      if ($node->nid && isset($node->field_registration_sw['und'][0]['value']) && $node->field_registration_sw['und'][0]['value'] !== 0) {
        $node->field_registration_sw['und'][0]['value'] = 0;
        node_save($node);
      }
    }
  }
}

/**
 * Implementation of hook_field_access
 * Hide Registration switch field.
 * @author Alexandr Kapelshikov <alex2cpw@gmail.com>
 */
function pg_contest_field_access($op, $field, $entity_type, $entity, $account) {

  if ($op == 'edit' && $field['field_name'] == AIRTRIBUNE_REGISTRATION_SW_FIELD && !empty($entity->{AIRTRIBUNE_DATES_FIELD}['und'][0]['value']) && ($entity->type == AIRTRIBUNE_PG_CONTEST_TYPE)) {
    global $user;

    $date = time() - 2 * 24 * 3600;
    // Event start date.
    $value = strtotime($entity->{AIRTRIBUNE_DATES_FIELD}['und'][0]['value']);

    // For allowed roles switch is always shown.
    $allowed_roles = array('admin');
    $intersect = array_intersect($user->roles, $allowed_roles);

    // Hide registration switch
    if ($value < $date && empty($intersect)) {
      return FALSE;
    }
  }
}

function get_takeoffs_for_flyingsite($flying_site_id) {
  $view = views_get_view('basic_marks_by_proximity');
  $view->set_arguments(array($flying_site_id));
  $view->preview('take_offs_pane', array($flying_site_id));
  $result = array();
  foreach ($view->result as $item) {
    $result[$item->id] = $item->eck_ent_basicmark_title;
  }
  return $result;
}

