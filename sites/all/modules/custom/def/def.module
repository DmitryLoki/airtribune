<?php

// TODO: Rename "Form Elements' AJAX Validation" (feav)

// TODO: Maybe exclude from validation those fields
// that don't have #validate/#element_validate functions attached.

/**
 * Implements hook_menu().
 */
function def_menu() {
  //~ $items['def/ajax'] = array(
    //~ //'title' => 'Clientside validation ajax callback',
    //~ 'page callback' => 'def_ajax',
    //~ // TODO: check access arguments
    //~ //'access arguments' => array('access content'),
    //~ 'access callback' => TRUE,
    //~ 'type' => MENU_CALLBACK,
  //~ );
  
  // Based on ajax_form_callback(). See system_menu().
  $items['def/ajax'] = array(
    //~ 'title' => 'AHAH callback',
    'page callback' => 'def_ajax_form_callback',
    'delivery callback' => 'ajax_deliver',
    'access callback' => TRUE,
    'theme callback' => 'ajax_base_page_theme',
    'type' => MENU_CALLBACK,
    'file path' => 'includes',
    'file' => 'form.inc',
  );
  
  return $items;
}

/**
 * Ajax callback.
 * 
 * See ajax_form_callback().
 */
function def_ajax_form_callback() {
  list($form, $form_state) = ajax_get_form();
  
  // Here we don't use drupal_process_form() directly as it is done in ajax_form_callback()
  // in order not to validate form twice.
  //~ drupal_process_form($form['#form_id'], $form, $form_state);
  $form = def_drupal_process_form($form['#form_id'], $form, $form_state);
  
  // We need to return the part of the form (or some other content) that needs
  // to be re-rendered so the browser can update the page with changed content.
  // Since this is the generic menu callback used by many Ajax elements, it is
  // up to the #ajax['callback'] function of the element (may or may not be a
  // button) that triggered the Ajax request to determine what needs to be
  // rendered.
  if (!empty($form_state['triggering_element'])) {
    $callback = $form_state['triggering_element']['#ajax']['callback'];
  }
  if (!empty($callback) && function_exists($callback)) {
    return $callback($form, $form_state);
  }
}

//$form_state['values'] = array();
// This is a part of drupal_process_form() up to form_builder() call.
function def_drupal_process_form($form_id, &$form, &$form_state) {
  $form_state['values'] = array();

  // With $_GET, these forms are always submitted if requested.
  if ($form_state['method'] == 'get' && !empty($form_state['always_process'])) {
    if (!isset($form_state['input']['form_build_id'])) {
      $form_state['input']['form_build_id'] = $form['#build_id'];
    }
    if (!isset($form_state['input']['form_id'])) {
      $form_state['input']['form_id'] = $form_id;
    }
    if (!isset($form_state['input']['form_token']) && isset($form['#token'])) {
      $form_state['input']['form_token'] = drupal_get_token($form['#token']);
    }
  }

  // form_builder() finishes building the form by calling element #process
  // functions and mapping user input, if any, to #value properties, and also
  // storing the values in $form_state['values']. We need to retain the
  // unprocessed $form in case it needs to be cached.
  $unprocessed_form = $form;
  $form = form_builder($form_id, $form, $form_state);
  
  return $form;
}

// TODO: For testing purposes only.
function def_ajax_tmp($form, $form_state) {
  $text = 'test';
  
  //~ $commands[] = ajax_command_alert($text);
  //~ return $commands;
  
  
  
  $element = def_target_element($form, $form_state);
  
  $form_state['submitted'] = TRUE;
  _form_validate($element, $form_state);
  $errors = form_get_errors();
  $errors = !empty($errors) ? array_values($errors) : array('no errors');
  $text = $errors[0];
  //~ dsm($errors);
  
  // https://api.drupal.org/api/drupal/includes%21ajax.inc/group/ajax/7
  // https://api.drupal.org/comment/50903#comment-50903
  $result = array(
    '#type' => 'ajax',
    '#commands' => array(
      ajax_command_alert($text),
    ),
  );
  
  return $result;
}

// TODO:
// See drupal_process_form()
// Rename
// def_validate() should return only data about validation errors
function def_validate($form, $form_state) {
  
  // Store $_SESSION['messages'] state to restore afterwards.
  $orig_session_msgs = isset($_SESSION['messages']) ? $_SESSION['messages'] : NULL;
  
  $form_state['values'] = array();
  $form = form_builder($form['#form_id'], $form, $form_state);
  
  $element = def_target_element($form, $form_state);
  
  // TODO: Add comment to this line.
  $form_state['submitted'] = TRUE;
  _form_validate($element, $form_state);
  
  
  
  // Get errors if any
  $errors = form_get_errors();
  
  // Restore $_SESSION['messages'] into its original state,
  // since we don't need to display any validation messages (i.e. store them in $_SESSION).
  // See drupal_set_message($message, 'error') in form_set_error() called by form_get_errors().
  $_SESSION['messages'] = $orig_session_msgs;
  
  
}

// TODO:
function def_target_element($form, $form_state) {
  // Define validation scope.
  $triggering_element = $form_state['triggering_element'];
  $array_parents = $triggering_element['#array_parents'];
  
  // TODO: Add check for field_collection.
  //~ dsm($form);
  $element = $form;
  foreach ($array_parents as $k => $array_parent) {
    // TODO: Check for field_collection.
    $element = $element[$array_parent];

    if (!empty($element['#field_name'])) {
      // Current triggering_element cardinality (this is only for fields).
      // Not every widget has cardinality. I.e. options_select
      if (isset($element['#cardinality'])) {
        $current = $element;
        // Data could be deeper in the array (e.g. [0][value]).
        for ($i = $k + 1; $i <= count($array_parents); $i++) {
          $current = $current[$array_parents[$i]];
          if (!empty($current['#field_name'])) {
            break;
          }
        }
      }
      $field_name = $current['#field_name'];
      $entity_type = $current['#entity_type'];
      $bundle = $current['#bundle'];

      $field_info = field_info_field($field_name);
      $instance_info = field_info_instance($entity_type, $field_name, $bundle);

      $field_type = $field_info['type'];
      $widget_type = $instance_info['widget']['type'];
      break;
    }
  }
  
  //~ dsm($triggering_element);
  //~ dsm($element);
  return $element;
  //~ return $triggering_element;
  //~ return $form['profile_pilot']['field_civl_id'];
}


// TODO:
// NOTE: If some elements are added through other modules' hook_form_alter(),
// they can be preprocessed separately using def_generic_element_preprocess() in those hooks.
function def_form_alter(&$form, &$form_state, $form_id) {
  // It is supposed that fields weren't attached yet.
  
  // TODO: Check if validation is enabled.
  
  $elements = def_target_generic_elements($form_state);
  foreach ($elements as $array_parents) {
    def_generic_element_preprocess($form, $array_parents);
  }
}

/**
 * Get array_parrents of generic form elements to validate.
 */
function def_target_generic_elements($form_state) {
  $elements = !empty($form_state['#def_generic_elements']) ? $form_state['#def_generic_elements'] : array();
  return $elements;
}

function def_add_generic_elements(&$form_state, $def_generic_elements) {
  if (!empty($def_generic_elements)) {
    foreach ($def_generic_elements as $k => $array_parents) {
      if (empty($array_parents)) {
        continue;
      }
      $key = array_shift($array_parents);
      $key .= '[' . implode('][', $array_parents) . ']';
      $form_state['#def_generic_elements'][$key] = $def_generic_elements[$k];
    }
  }
}

// TODO:
function def_generic_element_preprocess(&$form, $array_parents) {
  $key_exists = FALSE;
  //~ $element = drupal_array_get_nested_value($form, $array_parents);
  $element = &drupal_array_get_nested_value($form, $array_parents);
  
  if (isset($element['#type'])) {
    $element_type = $element['#type'];
    $plugin = def_generic_plugin($element_type);
    if (!empty($plugin)) {
      // Add Ajax validator to the element.
      $function = $plugin['preprocessor'];
      $function($element, $form_state);
    }
  }
}

/**
 * Implements hook_field_widget_form_alter().
 *
 * Adds ajax handler to field widgets.
 * Ctools plugins should be used for individual handlers.
 */
function def_field_widget_form_alter(&$element, &$form_state, $context) {
  // TODO: Alter only widgets for required forms,
  // not to add to editable views.
  
  if (!def_validation_enabled($element, $form_state, 'field')) {
    return;
  }
  
  //~ $form_id = $form_state['build_info']['form_id'];
  
  //~ $field_name = $context['field']['field_name'];
  $field_type = $context['field']['type'];
  $widget_type = $context['instance']['widget']['type'];
  
  
  //~ dsm($field_type);
  //~ dsm($form_state);
  //~ dsm($form_id);
  //~ dsm($context);
  //~ dsm($field_info);
  
  $plugin = def_field_plugin($field_type, $widget_type);
  if (!empty($plugin)) {
    // Add Ajax validator to the widget.
    $function = $plugin['preprocessor'];
    $function($element, $form_state, $context);
    
    // Some plugins may implement their own #after_build functions.
    // Since during elements' validation, form is retrieved from cache and hook_field_widget_form_alter() isn't called,
    // we need to include plugin file to form in order not to get "function not found" error in form_builder() (see def_validate())
    // and call plugin's #after_build from within def_field_element_after_build().
    if (isset($plugin['after_build'])) {
      $element['#after_build'][] = 'def_field_widget_form_after_build';
      $element['#def_after_build_plugin']['module'] = $plugin['plugin module'];
      $element['#def_after_build_plugin']['type'] = $plugin['plugin type'];
      $element['#def_after_build_plugin']['id'] = $plugin['name'];
    }
  }
}

// Widget form #after_build.
// See comment in def_field_widget_form_alter().
function def_field_widget_form_after_build($element, &$form_state) {
  //
  if (isset($element['#def_after_build_plugin'])) {
    $info = $element['#def_after_build_plugin'];
    $plugin = ctools_get_plugins($info['module'], $info['type'], $info['id']);
    if (isset($plugin['after_build'])) {
      $function = $plugin['after_build'];
      $element = $function($element, $form_state);
    }
  }
  return $element;
}

// TODO:
// Maybe also pass $context for $plugin_type == 'field' case
function def_validation_enabled($element, $form_state, $plugin_type) {
  return TRUE;
}

/**
 * Get FIELD validator plugin.
 */
function def_field_plugin($field_type, $widget_type) {
  // Get at_validator plugins.
  ctools_include('plugins');
  $plugins = ctools_get_plugins('def', 'field');
  foreach ($plugins as $plugin) {
    if ($plugin['field_type'] == $field_type && $plugin['widget_type'] == $widget_type) {
      return $plugin;
    }
  }

  return FALSE;
}

// TODO: Redo into singe function with def_field_plugin().
function def_generic_plugin($element_type) {
  // Get at_validator plugins.
  ctools_include('plugins');
  $plugins = ctools_get_plugins('def', 'generic');
  foreach ($plugins as $plugin) {
    if ($plugin['element_type'] == $element_type) {
      return $plugin;
    }
  }

  return FALSE;
}

/**
 * Prepare default ajax settings for plugins.
 */
function def_ajax_defaults() {
  $defaults = array();
  $defaults = array(
    'path' => 'def/ajax',
    'callback' => 'def_ajax_tmp',
    //'progress' => 'none',
  );

  return $defaults;
}


/**
 * Implements hook_element_info_alter().
 */
function def_element_info_alter(&$types) {
  //~ foreach ($types as $type_name => $type_info ) {
    //~ if (!empty($type_info['#input'])) {
      //~ $types[$type_name]['#process'][] = 'fapi_validation_element_process';
    //~ }
  //~ }
  
  
  
  // Allow def plugins to alter elements info.
  foreach (array('field', 'generic') as $plugin_type) {
    $plugins = ctools_get_plugins('def', $plugin_type);
    foreach ($plugins as $plugin) {
      if (isset($plugin['element_info_alter'])) {
        $function = $plugin['element_info_alter'];
        
        
        $data = $function();
        //~ $types = $plugin['element_info_alter']['types'];
        $element_types = $data['types'];
        //~ dsm($types); return;
        foreach ($element_types as $element_type) {
          if (isset($types[$element_type])) {
            $types[$element_type]['#process'][] = 'def_element_process';
            $types[$element_type]['#def_element_info_alter_plugin']['module'] = $plugin['plugin module'];
            $types[$element_type]['#def_element_info_alter_plugin']['type'] = $plugin['plugin type'];
            $types[$element_type]['#def_element_info_alter_plugin']['id'] = $plugin['name'];
          }
        }
      }
    }
  }
}

/**
 * Generic #process callback to create the element.
 */
function def_element_process($element, &$form_state, $complete_form) {
  // TODO: Check if validation is enabled
  
  if (isset($element['#def_element_info_alter_plugin'])) {
    $info = $element['#def_element_info_alter_plugin'];
    $plugin = ctools_get_plugins($info['module'], $info['type'], $info['id']);
    if (isset($plugin['element_info_alter'])) {
      $function = $plugin['element_info_alter'];
      $data = $function();
      
      $process = $data['process'];
      $element = $process($element, $form_state, $complete_form);
    }
  }
  
  return $element;
}

// =======================================================
// Ctools
// =======================================================

/**
 * Implements hook_ctools_plugin_type().
 */
// TODO: 'use hooks' ?
function def_ctools_plugin_type() {
  // Used for field widgets.
  $plugins['field'] = array(
    'use hooks' => FALSE,
  );
  // Used for generic form elements.
  $plugins['generic'] = array(
    'use hooks' => FALSE,
  );
  return $plugins;
}

/**
 * Implements hook_ctools_plugin_directory().
 */
function def_ctools_plugin_directory($module, $plugin) {
  if ($module == 'def' && $plugin == 'field') {
    return 'plugins/validators/field';
  }
  if ($module == 'def' && $plugin == 'generic') {
    return 'plugins/validators/generic';
  }
}
