<?php


/**
 * Implements hook_form_FORM_ID_alter(). for user_login_block
 */
function at_core_auth_form_user_login_block_alter(&$form, &$form_state) {
  array_unshift($form['#validate'], 'at_core_auth_login_authenticate_validate');
  array_unshift($form['#validate'], 'at_core_auth_grab_password_validate');
}

/**
 * Implements hook_form_FORM_ID_alter(). for user_login_form
 */
function at_core_auth_form_user_login_alter(&$form, $form_state) {
  $key = array_search('user_login_authenticate_validate', $form['#validate']);
  unset($form['#validate'][$key]);
  array_unshift($form['#validate'], 'at_core_auth_login_authenticate_validate');
  array_unshift($form['#validate'], 'at_core_auth_grab_password_validate');
  dpm($form);
}

/**
 * Implements hook_form_FORM_ID_alter(). for user_register_form
 */
function at_core_auth_form_user_profile_form_alter(&$form, $form_state) {
  array_unshift($form['#submit'], 'at_core_auth_grab_password_validate');
}

/**
* Implements hook_form_FORM_ID_alter(). for password_policy_password_tab
*/
function at_core_auth_form_password_policy_password_tab_alter(&$form, &$form_state) {
  array_unshift($form['#validate'], 'at_core_auth_grab_password_validate');
}

/**
 * store password from logon forms in ldap_user_ldap_provision_pwd static variable
 * for use in provisioning to ldap
 */
function at_core_auth_grab_password_validate($form, &$form_state) {

   // This is not a login form but profile form and user is inserting password to update email
  if (!empty($form_state['values']['current_pass_required_values'])) {
    if (!empty($form_state['values']['current_pass']) && empty($form_state['values']['pass'])) {
      at_core_auth_provision_pwd('set', $form_state['values']['current_pass']);
    }
    // Or this is a profile form where the user is updating their own password
    elseif (!empty($form_state['values']['pass'])) {
        at_core_auth_provision_pwd('set', $form_state['values']['pass']);
    }
  }
  // otherwise a logon form
  elseif (!empty($form_state['values']['pass'])) {
    at_core_auth_provision_pwd('set', $form_state['values']['pass']);
  }

}

/**
 * A validate handler on the login form. Check supplied username/password
 * against local users table. If successful, $form_state['uid']
 * is set to the matching user ID.
 */
function at_core_auth_login_authenticate_validate($form, &$form_state) {
  $password = trim($form_state['values']['pass']);
  if (!empty($form_state['values']['name']) && !empty($password)) {
    // Do not allow any login from the current user's IP if the limit has been
    // reached. Default is 50 failed attempts allowed in one hour. This is
    // independent of the per-user limit to catch attempts from one IP to log
    // in to many different user accounts.  We have a reasonably high limit
    // since there may be only one apparent IP for all users at an institution.
    if (!flood_is_allowed('failed_login_attempt_ip', variable_get('user_failed_login_ip_limit', 50), variable_get('user_failed_login_ip_window', 3600))) {
      $form_state['flood_control_triggered'] = 'ip';
      return;
    }
    $account = db_query("SELECT * FROM {users} WHERE name = :name AND status = 1", array(':name' => $form_state['values']['name']))->fetchObject();
    if ($account) {
      if (variable_get('user_failed_login_identifier_uid_only', FALSE)) {
        // Register flood events based on the uid only, so they apply for any
        // IP address. This is the most secure option.
        $identifier = $account->uid;
      }
      else {
        // The default identifier is a combination of uid and IP address. This
        // is less secure but more resistant to denial-of-service attacks that
        // could lock out all users with public user names.
        $identifier = $account->uid . '-' . ip_address();
      }
      $form_state['flood_control_user_identifier'] = $identifier;

      // Don't allow login if the limit for this user has been reached.
      // Default is to allow 5 failed attempts every 6 hours.
      if (!flood_is_allowed('failed_login_attempt_user', variable_get('user_failed_login_user_limit', 5), variable_get('user_failed_login_user_window', 21600), $identifier)) {
        $form_state['flood_control_triggered'] = 'user';
        return;
      }
    }
    // We are not limited by flood control, so try to authenticate.
    // Set $form_state['uid'] as a flag for user_login_final_validate().
    $form_state['uid'] = at_core_auth_authenticate($form_state['values']['name'], $password);
  }
}

/**
 * Try to validate the user's login credentials through Core API.
 *
 * @param $name
 *   User name to authenticate.
 * @param $password
 *   A plain-text password, such as trimmed text from form values.
 * @return
 *   The user's uid on success, or FALSE on failure to authenticate.
 */
function at_core_auth_authenticate($name, $password) {
  $uid = FALSE;
  if (!empty($name) && !empty($password)) {
    $account = user_load_by_name($name);
    if ($account) {
      $sync = _get_class_by_entity('user', $account);
      $token = $sync->get_auth_token($account->mail, $password);
      dpm($token);
      if (!empty($token)) {
        $uid = $account->uid;
      }
    }
  }
  return $uid;
}

/**
 * function to:
 *   -- store user entered password during pageload
 *   and protect unencrypted user password from other modules
 *
 *   @param enum string $action 'get' | 'set'
 *   @param string | FALE $value as user entered password
 */
function at_core_auth_provision_pwd($action, $value = NULL, $reset = FALSE) {

  static $current_user_pass;

  if ($reset) {
    $current_user_pass = NULL;
  }

  if ($action == 'set') {
    $current_user_pass = $value;
  }
  elseif ($action == 'get' && $current_user_pass) {
    return $current_user_pass;
  }
  else {
    return FALSE;
  }

}

/**
 * Get auth token for CoreAPI, using plain password from user_login submitted form.
 * @see #4498
 */
function at_core_auth_login_get_core_api_auth_token(&$form, &$form_state) {
  $user = user_load($form_state['uid']);
  $sync = _get_class_by_entity('user', $user);
  $token = $sync->get_auth_token($account->mail, $password);
  user_cookie_save(array("auth_token_{$user->uid}" => $token));
}
