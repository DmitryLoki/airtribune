<?php
/**
 * @file
 * Contains classes for Client connections handlers.
 */

/**
 * Class for Drupal client connections, REST D7.
 */
class clients_connection_drupal_rest_at_core extends clients_connection_base {

  function credentialsProperties() {
    return array();
  }
  // ============================================ Connection form UI.

  /**
   * Extra form elements specific to a class's edit form.
   *
   * @param $form_state
   *  The form state from the main form, which you probably don't need anyway.
   *
   * @see clients_connection_form()
   * @see clients_connection_form_submit()
   */
  function connectionSettingsFormAlter(&$form, &$form_state) {
    $form['endpoint']['#default_value'] = '';//at_core_sync_get_api_url();
    $form['endpoint']['#description'] = t('Remote service URL e.g. http://site.com/service-endpoint');
  }

  /**
   * Submit handler for saving/updating connections of this class.
   *
   * @see clients_connection_form_submit()
   */
  function connectionSettingsForm_submit($form, &$form_state) {
    // This is here to show an example of how this method works.
    parent::connectionSettingsForm_submit($form, $form_state);
  }

  // ============================================ Resource retrieval.

  /**
   * Load a remote entity.
   *
   * @param $entity_type
   *  The entity type to load.
   * @param $id
   *  The (remote) ID of the entity.
   * @return
   *  An entity object.
   */
  function remote_entity_load($entity_type, $id) {
    if (empty($id)) {
      return FALSE;
    }
    $this->get_url_for_entity($entity_type, $id);
    $query = $this->getRemoteEntityQuery('select');
    $query->base($entity_type);
    $query->entityCondition('entity_id', $id);
    $result = $query->execute();

    return $result;
  }

  /**
   * Save a remote entity.
   *
   * @param $entity_type
   *  The entity type to save.
   * @param $entity
   *  The entity to save.
   * @return
   *  If the entity is being created remotely, the new remote GUID.
   */
  function remote_entity_save($entity_type, $entity, $remote_properties = array()) {
    // If entity not yet saved remotely - entity haven't remote ID property.
    // So use 'insert', otherwise - 'update'.
    $action = empty($entity->remote_id) ? 'insert' : 'update';
    $this->get_url_for_entity($entity_type, $entity->remote_id, $action);

    $query = $this->getRemoteEntityQuery($action);
    $query->setEntity($entity_type, $entity);

    if ($action == 'insert') {
      $result = $query->execute();
      return $result->remote_id;
    }
    else {
      $this->endpoint .= '/' . $entity->remote_id;
      $query->addFields($remote_properties);
      $query->execute();
    }
  }

  function get_url_for_entity($entity_type, $id=null, $action='') {
    $url = at_core_sync_get_api_url();
    if ($entity_type == 'profile2') {
      if ($action == 'insert') {
        $this->url = $url . '/user/register/site';
      }
      else {
        $this->url = $url . '/user/' . $id;
      }
    }
  }

  function getRemoteEntityQuery($query_type = 'select') {
    switch ($query_type) {
      case 'select':
        return new ATCoreSelectQuery($this);
      case 'insert':
        return new ATCoreInsertQuery($this);
      case 'update':
        return new ATCoreUpdateQuery($this);
      case 'delete':
        return new ATCoreDeleteQuery($this);
    }
  }

  /**
   * Common helper for reacting to an error from a REST call.
   *
   * Gets the error from the response, logs the error message,
   * and throws an exception, which should be caught by the module making use
   * of the Clients connection API.
   *
   * @param $response
   *  The REST response data, decoded.
   *
   * @throws Exception
   */
  function handleRestError($response) {
    if ($response->code != 200) {
      watchdog('clients', 'Error with REST request. Error was code @code with error "@error" and message "@message".', array(
        '@code'     => $response->code,
        '@error'    => $response->error,
        '@message'  => $response->status_message,
      ));

      throw new Exception(t("Clients connection error, got message '@message'.", array(
        '@message' => $response->status_message,
      )), $response->code);
    }
  }

  /**
   * API function to request a remote resource.
   *
   * (This function has a rubbish name and parameters for historical reasons:
   * XMLRPC connection classes were developed first.)
   *
   * @param $method
   *  The path of the remote resource to retrieve.
   * @param $method_params
   *  A flat array of further parameters for the request. This should contain:
   *  - The HTTP method.
   *  - (optional) An array of data for the request, such as POST data.
   *
   * @return
   *  Whatever is returned from the remote site.
   */
  function callMethodArray($method, $method_params = array()) {
    $resource_path = $method;
    $http_method = array_shift($method_params);
    // The data array doesn't have to be present, so we have to fiddle about
    // to make sure we don't pass a NULL for it to makeRequest().
    if (count($method_params)) {
      $data = array_shift($method_params);
    }
    else {
      $data = array();
    }

    return $this->makeRequest($resource_path, $http_method, $data);
  }

  /**
   * Make a REST request.
   *
   * Examples:
   * Retrieve a user:
   *  makeRequest('user/{pers-id}', 'GET');
   * Create a sponsor:
   *  makeRequest('user/{pers-id}/sponsor', 'POST', $data);
   *
   * @param $resource_path
   *  The path of the resource. Eg, 'race', 'user/pers-140211-3284629059', etc.
   * @param $http_method
   *  The HTTP method. One of 'GET', 'POST', 'PUT', 'DELETE'. For an explanation
   *  of how the HTTP method affects the resource request, see the Services
   *  documentation at http://drupal.org/node/783254.
   * @param $data = array()
   *  (Optional) An array of data to pass to the request.
   *
   * @return
   *  The data from the request response.
   */
  function makeRequest($resource_path, $http_method, $data = array()) {
    if ($http_method != 'GET' && !isset($this->token)) {
//      $this->getAuthToken();
    }

    $data = drupal_json_encode($data);
    $headers = array(
      'Content-Type' => 'application/json',
    );
    $options = array(
      'headers' => $headers,
      'method'  => $http_method,
      'data'    => $data,
      'token'    => $token,
    );

    $response = drupal_http_request($resource_path, $options);
//    $this->handleRestError($response);

    $result = json_decode($response->data);
    return $result;
  }

}

module_load_include('inc', 'profile2', 'profile2.info');

class RemoteProfileMetadataController extends Profile2MetadataController {
  // copied from RemoteEntityAPIDefaultMetadataController
  public function entityPropertyInfo() {
    // Let the parent class handle the schema properties.
    $parent_info = parent::entityPropertyInfo();

    // This is so awkward I am surely doing it wrong :/
    $properties = $parent_info[$this->type]['properties'];

    // Add some labels and types for our schema properties, allowing for the
    // fact that entity type modules may have changed the schema to suit their
    // own purposes.
    if (isset($properties['created'])) {
      $properties['created']['type'] = 'date';
      $properties['created']['label'] = t("Created date");
      $properties['created']['description'] = t("The date the entity was created.");
    }
    if (isset($properties['changed'])) {
      $properties['changed']['type'] = 'date';
      $properties['changed']['label'] = t("Changed date");
      $properties['changed']['description'] = t("The date the entity was last changed.");
    }
    if (isset($properties['remote_saved'])) {
      $properties['remote_saved']['type'] = 'date';
      $properties['remote_saved']['label'] = t("Remote save date");
      $properties['remote_saved']['description'] = t("The date the entity was last saved remotely.");
    }
    if (isset($properties['expires'])) {
      $properties['expires']['type'] = 'date';
      $properties['expires']['label'] = t("Expiry date");
      $properties['expires']['description'] = t("The date the local copy of the entity expires.");
    }
    if (isset($properties['needs_remote_save'])) {
      $properties['needs_remote_save']['type'] = 'boolean';
      $properties['needs_remote_save']['label'] = t("Needs remote save");
      $properties['needs_remote_save']['description'] = t("Boolean indicating whether the entity needs to be saved remotely.");
    }
    if (isset($properties['deleted'])) {
      $properties['deleted']['type'] = 'boolean';
      $properties['deleted']['label'] = t("Deleted");
      $properties['deleted']['description'] = t("Boolean indicating that the entity is marked for deletion.");
    }

    // Get the property type map out of the connection for our remote entity
    // type.
    // First get the resource for our entity type, and then the connection.
    $resource = clients_resource_get_for_component('remote_entity', $this->type);
    if (empty($resource)) {
      // It's possible to come here and find no resource for a remote entity
      // type. This happens when _entity_defaults_rebuild() imports resources
      // defined in code, and during its own invocation of entity hooks, other
      // modules make use of the Entity Metadata API.
      // All we can do it bail here, since our resource does not exist.
      // remote_entity_clients_connection_defaults_rebuild() takes care of
      // causing another rebuild of Entity Metadata properties afterwards.
      return $parent_info;
    }

    $connection = $resource->getConnection();
//    $property_type_map = $connection->entity_property_type_map();
    if (method_exists($connection, 'entity_property_type_callbacks')) {
      $property_type_callbacks = $connection->entity_property_type_callbacks();
    }

    // Get the remote table info.
    $table_info = remote_entity_get_query_table_info($connection->name, $this->info['remote base table']);

    // Properties from the property map.
    foreach ($this->info['property map'] as $property => $remote_property) {
      // Type defaults to 'text'.
      $type = 'text';
      $remote_type = NULL;
      // Now see if that should actually be something else, by inspecting the
      // remote table info and the remote property type map.
      if (isset($table_info['fields'][$remote_property])) {
        // If the table info defines the field...
        $remote_type = $table_info['fields'][$remote_property]['type'];
        if (isset($property_type_map[$remote_type])) {
          // ...and the property map has the type, take our type from the map.
          $type = $property_type_map[$remote_type];
        }
      }

      $properties[$property] = array(
        'label' => $property,
        'description' => t("A remote property."),
        'type' => $type,
        'getter callback' => 'remote_entity_entity_mapped_property_get',
        'setter callback' => 'remote_entity_entity_mapped_property_set',
        // Custom property to help our getters and setters.
        'remote_property' => $remote_property,
      );

      // If the connection specified particular callbacks for the remote type
      // (and we have a remote type), add them in here.
      if (isset($remote_type) && isset($property_type_callbacks[$remote_type])) {
        $properties[$property] = $property_type_callbacks[$remote_type] + $properties[$property];
      }
    }

    // Remove the setter callback from the property for the remote id: it
    // should not be set locally.
    // Get the remote id property.
    $id_property = $this->info['remote entity keys']['remote id'];
    // Flip the property map so we can find its local name.
    $flipped_property_map = array_flip($this->info['property map']);
    // Get the local property name that maps to the remote id property.
    $local_id_property = $flipped_property_map[$id_property];
    // Unset the callback.
    unset($properties[$local_id_property]['setter callback']);

    $info = array();
    $info[$this->type]['properties'] = $properties;

    return $info;
  }

}