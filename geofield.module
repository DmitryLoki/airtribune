<?php

require_once('geofield.elements.inc');
require_once('geofield.widgets.inc');
require_once('geofield.formatters.inc');
require_once('geofield.openlayers.inc');
require_once('geofield.feeds.inc');

/**
 * Contrib modules can check this global variable to see if geofield is running the new WKB geom schema
 */
$geofield_geom_schema = TRUE;

/**
 * Implements hook_field_info().
 */
function geofield_field_info() {
  return array(
    'geofield' => array(
      'label' => 'Geofield',
      'description' => t('This field stores geo information.'),
      'default_widget' => 'geofield_wkt',
      'default_formatter' => 'geofield_wkt',
      'instance_settings' => array(
        'local_solr' => array(
          'enabled' => FALSE,
          'lat_field' => 'lat',
          'lng_field' => 'lng',
        ),
      ),
      'settings' => array(
        'srid' => '4326',
        'backend' => 'default',
      ),
      'property_type' => 'geofield',
      'property_callbacks' => array('geofield_property_info_callback'),
      'microdata' => TRUE,
    ),
  );
}

/**
 * Implements hook_field_settings_form().
 */
function geofield_field_settings_form($field, $instance, $has_data) {
  ctools_include('plugins');
  $settings = $field['settings'];

  $backend_options = array();
  $backends = ctools_get_plugins('geofield', 'geofield_backend');
  foreach ($backends as $id => $backend) {
    if (isset($backend['requirements'])) {
      if ($backend['requirements']) {
        $callback = $backend['requirements'];
        $error = '';
        if (!$callback($error)) {
          $form['backend_error'][] = array(
            //@@TODO: Use t() func
            //@@TODO: css to add some red and bold
            '#markup' => '<div class="geofield-backend-error">' . $backend['title'] . ' not usable because ' . $error . '</div>',
          );
          continue;
        }
      }
    }
    $backend_options[$id] = $backend['title'];
  }

  $form['backend'] = array(
    '#type' => 'select',
    '#title' => 'Storage Backend',
    '#default_value' => $settings['backend'],
    '#options' => $backend_options,
    '#description' => "Select the Geospatial storage backend you would like to use to store geofield geometry data. If you don't know what this means, select 'Default'.",
    '#disabled' => $has_data,
  );
  
  $form['settings'] = array(
    '#tree' => TRUE,
  );

  // Expose backend-settings, if they have them
  foreach ($backends as $id => $backend) {
    if (isset($backend['settings'])) {
      if ($backend['settings']) {
        $callback = $backend['settings'];
        $form[$id] = array(
          '#type' => 'fieldset',
          '#tree' => TRUE,
          '#title' => $backend['title'] . ' Settings',
          '#states' => array(
            'visible' => array(
              ':input[name="field[settings][backend]"]' => array('value' => $id),
            ),
          ),
        );
        $form[$id] = array_merge($form[$id], $callback($field, $instance, $has_data));
      }
    }
  }

  return $form;
}

function geofield_field_validate($entity_type, $entity, $field, $instance, $langcode, $items, &$errors) {
  //@@TODO: If field is marked as required, then check to make sure the geometry is not Empty as per geoPHP
}

/**
 * Implements hook_field_presave().
 */
function geofield_field_presave($entity_type, $entity, $field, $instance, $langcode, &$items) {
  if ($field['type'] === 'geofield') {
    ctools_include('plugins');
    $backend = ctools_get_plugins('geofield', 'geofield_backend', $field['settings']['backend']);
    // For each delta, we compute all the auxiliary columns and transform the geom column into a geometry object
    // We then pass the geometry object (now stored in the geom column) to the backend to prepare it for insertion into the database
    foreach ($items as $delta => $item) {
      $items[$delta] = geofield_compute_values($item);
      $items[$delta]['geom'] = $backend['save']($items[$delta]['geom']);
    }
  }
}

/**
 * Implements hook_content_is_empty().
 */
function geofield_field_is_empty($item, $field) {
  if (isset($item['input_format'])) {
    switch ($item['input_format']) {
      case GEOFIELD_INPUT_LAT_LON:
        return ((trim($item['geom']['lat']) == '') || (trim($item['geom']['lon']) == ''));
      case GEOFIELD_INPUT_BOUNDS:
        return ((trim($item['geom']['top']) == '') || (trim($item['geom']['right']) == '') ||
        (trim($item['geom']['bottom']) == '') || (trim($item['geom']['left']) == ''));
    }
  }
  //@@TODO: Check if it's an empty geometry as per geoPHP $geometry->empty()
  return empty($item['geom']);
}

/**
 * Implements hook_view_api().
 */
function geofield_views_api() {
  return array(
    'api' => '3.0',
    'path' => drupal_get_path('module', 'geofield') . '/views',
  );
}

/**
 * Implements hook_ctools_plugin_type().
 */
function geofield_ctools_plugin_type() {
  return array(
    'geofield_backend' => array(),
    'behaviors' => array(
      'use hooks' => TRUE,
    )
  );
}

/**
 * Implements hook_ctools_plugin_api().
 */
function geofield_ctools_plugin_api($module, $api) {
  return array('version' => 1);
}

/**
* Implementation of hook_ctools_plugin_directory().
*/
function geofield_ctools_plugin_directory($module, $plugin) {
  if ($plugin == 'geofield_backend') {
    return 'includes/' . $plugin;
  }
}

 /**
 * Implements hook_field_instance_settings_form().
 */
function geofield_field_instance_settings_form($field, $instance) {
  $form = array();
  // Add in local solr settings
  if (module_exists('apachesolr')) {

    if (isset($instance['settings']['solrspatial'])) $setting = $instance['settings']['solrspatial'];
    else $setting = array();

    $form['solrspatial'] = array(
      '#type' => 'fieldset',
      '#title' => t('Local Solr Settings'),
      '#tree' => TRUE,
    );

    $form['solrspatial']['enabled'] = array(
      '#type' => 'checkbox',
      '#title' => t('Index field in Solr for spatial search'),
      '#default_value' => isset($setting['enabled']) ? $setting['enabled'] : '',
    );

    $form['solrspatial']['lat_field'] = array(
      '#type' => 'textfield',
      '#title' => t('Name of the Solr Latitude Field'),
      '#default_value' => isset($setting['lat_field']) ? $setting['lat_field'] : '',
    );

    $form['solrspatial']['lng_field'] = array(
      '#type' => 'textfield',
      '#title' => t('Name of the Solr Lonitude Field'),
      '#default_value' => isset($setting['lng_field']) ? $setting['lng_field'] : '',
    );
    $form['solrspatial']['latlng_field'] = array(
      '#type' => 'textfield',
      '#title' => t('Name of the Solr LatLon Field'),
      '#default_value' => isset($setting['latlng_field']) ? $setting['latlng_field'] : '',
    );
  }

  return $form;
}

/**
 * Geofield Compute Values
 *
 * Compute all dependant values. We compute all other values from whichever
 * column is specified in the master_column value
 *
 * Steps:
 * 1. Load the geoPHP library
 * 2. Load the Geometry object from the master-column
 * 3. Get out all the computer values from the Geometry object
 * 4. Set all the values
 */
function geofield_compute_values($raw_data, $input_format = NULL) {
  // If raw_data is NULL, false, or otherwise empty, just return an empty array of values
  if (empty($raw_data)) {
    return array();
  }

  // Load up geoPHP to do the conversions
  $geophp = geophp_load();
  if (!$geophp) {
    drupal_set_message(t("Unable to load geoPHP library. Not all values will be calculated correctly"), 'error');
    return;
  }

  $geometry = geofield_geometry_from_values($raw_data, $input_format);

  // Get values from geometry
  if (!empty($geometry)) {
    $values = geofield_get_values_from_geometry($geometry);
  }
  else {
    $values = array();
  }

  return $values;
}

function geofield_geometry_from_values($raw_data, $input_format = NULL) {
  // Load up geoPHP to do the conversions
  $geophp = geophp_load();
  if (!$geophp) {
    drupal_set_message(t("Unable to load geoPHP library. Not all values will be calculated correctly"), 'error');
    return;
  }

  if (is_array($raw_data)) {
    if (!empty($raw_data['input_format'])) {
      if ($raw_data['input_format'] == GEOFIELD_INPUT_LAT_LON) {
        $geometry = new Point($raw_data['geom']['lon'], $raw_data['geom']['lat']);
      }
      elseif ($raw_data['input_format'] == GEOFIELD_INPUT_BOUNDS) {
        $wkt_bounds_format = 'POLYGON((left bottom,right bottom,right top,left top,left bottom))';
        $wkt = strtr($wkt_bounds_format, array('top' => $raw_data['geom']['top'],
          'right' => $raw_data['geom']['right'],
          'bottom' => $raw_data['geom']['bottom'],
          'left' => $raw_data['geom']['left']));
        $geometry = geoPHP::load($wkt);
      }
      else {
        $geometry = geoPHP::load($raw_data['geom'], $raw_data['input_format']);
      }
    } else {
      // No input format - let geoPHP figure it out
      if (!empty($raw_data['geom'])) {
        $geometry = geoPHP::load($raw_data['geom']);
      }
      // Special case, raw input (Services/Feeds) that only specifies lat/lon.
      elseif (!empty($raw_data['lat']) && !empty($raw_data['lon'])) {
        $geometry = new Point($raw_data['lon'], $raw_data['lat']);
      }
    }
  }
  else {
    if ($input_format) {
      $geometry = geoPHP::load($raw_data, $input_format);
    }
    else {
      // All we have at this point is a raw string. let GeoPHP figure it out
      $geometry = geoPHP::load($raw_data);
    }
  }

  return $geometry;
}

/**
 * Given a geometry object from geoPHP, return a values array
 */
function geofield_get_values_from_geometry($geometry) {
  $values = array();

  $centroid = $geometry->getCentroid();
  $bounding = $geometry->getBBox();

  $values['geom'] = $geometry;

  $values['geo_type'] = drupal_strtolower($geometry->getGeomType());

  if ($centroid) {
    $values['lat'] = $centroid->y();
    $values['lon'] = $centroid->x();
  }

  $values['top'] = $bounding['maxy'];
  $values['bottom'] = $bounding['miny'];
  $values['right'] = $bounding['maxx'];
  $values['left'] = $bounding['minx'];

  $values['geohash'] = $geometry->out('geohash');

  return $values;
}

/**
 * Implements hook_apachesolr_field_mappings().
 */
function geofield_apachesolr_field_mappings() {
  return array(
    'geofield' => array(
      'indexing_callback' => 'geofield_apachesolr_index',
      'facets' => TRUE,
    )
  );
}

/**
 * Name callback for field name
 */
function geofield_apachesolr_index($node, $field_name, $index_key, $field_info) {
  $return = array();
  if (isset($node->$field_name)) {
    // Load the instance settings for the field
    $instance = field_info_instance('node', $field_name, $node->type);
    if (!empty($instance['settings']['solrspatial'])) {
      if ($values = field_get_items('node', $node, $field_name)) {
        $values = reset($values);
        $return = array(
          array(
            'key' => $instance['settings']['solrspatial']['lat_field'],
            'value' => $values['lat']
          ),
          array(
            'key' => $instance['settings']['solrspatial']['lng_field'],
            'value' =>  $values['lon']
          ),
          array(
            'key' => $instance['settings']['solrspatial']['latlng_field'],
            'value' =>  $values['lat'] . ',' . $values['lon']
          ),
          array(
            'key' => 'ss_geo_wkt',
            'value' => $values['wkt'],
          ),
        );
      }
    }
  }

  return $return;
}

/**
 * Implements hook_apachesolr_query_alter().
 */
function geofield_apachesolr_query_alter($query) {
  // Add the WKT field field
  $query->addParam('fl', 'ss_geo_wkt');
}


// Latitude and Longitude string conversion
// ----------------------------------------

/**
 * Decimal-Degrees-Seconds to Decimal Degrees
 *
 * Converts string to decimal degrees. Has some error correction for messy strings
 */
function geofield_latlon_DMStoDEC($dms) {
  if (is_numeric($dms)) {
    // It's already decimal degrees, just return it
    return $dms;
  }

  // If it contains both an H and M, then it's an angular hours
  if (stripos($dms, 'H') !== FALSE && stripos($dms, 'M') !== FALSE) {
    $dms = strtr($dms, "'\"HOURSMINTECNDAhoursmintecnda", "  ");
    $dms = preg_replace('/\s\s+/', ' ', $dms);

    $dms = explode(" ", $dms);
    $deg = $dms[0];
    $min = $dms[1];
    $sec = $dms[2];

    $dec = floatval(($deg*15) + ($min/4) + ($sec/240));

    return $dec;
  }

  // If it contains an S or a W, then it's a negative
  if (stripos($dms, 'S') !== FALSE || stripos($dms, 'W') !== FALSE) {
    $direction = -1;
  }
  else {
    $direction = 1;
  }

  // Strip all characters and replace them with empty space
  $dms = strtr($dms, "ï¿½'\"NORTHSEAWnorthseaw'", " ");
  $dms = preg_replace('/\s\s+/', ' ', $dms);

  $dms = explode(" ", $dms);
  $deg = $dms[0];
  $min = $dms[1];
  $sec = $dms[2];

  // Direction should be checked only for nonnegative coordinates
  $dec = floatval($deg+((($min*60)+($sec))/3600));
  if ($dec > 0) {
    $dec = $direction * $dec;
  }
  return $dec;
}


/**
 * Decimal Degrees to Decimal-Degrees-Seconds
 *
 * Converts decimal longitude / latitude to DMS ( Degrees / minutes / seconds )
 */
function geofield_latlon_DECtoDMS($dec, $axis) {
  if ($axis == 'lat') {
    if ($dec < 0) $direction = 'S';
    else $direction = 'N';
  }
  if ($axis == 'lon') {
    if ($dec < 0) $direction = 'W';
    else $direction = 'E';
  }

  $vars = explode(".", $dec);
  $deg = abs($vars[0]);
  if (isset($vars[1])) {
    $tempma = "0." . $vars[1];
  }
  else {
    $tempma = "0";
  }

  $tempma = $tempma * 3600;
  $min = floor($tempma / 60);
  $sec = $tempma - ($min*60);

  return $deg . "&deg; " . $min . "' " . round($sec, 3) . "\" " . $direction;
}

/**
 * Decimal Degrees to Celestial coordinate system (CCS) units
 *
 * Converts decimal latitude to DMS ( Degrees / minutes / seconds ) and decimal longitude to Angular Hours / Minutes / Seconds
 */
function geofield_latlon_DECtoCCS($dec, $axis) {

  // Declination (celestial latitude) should be representeted in Degrees / minutes / seconds
  if ($axis == 'lat') {
    $vars = explode("." , $dec);
    $deg = $vars[0];
    if (isset($vars[1])) {
      $tempma = "0." . $vars[1];
    }
    else {
      $tempma = "0";
    }

    $tempma = $tempma * 3600;
    $min = floor($tempma / 60);
    $sec = $tempma - ($min*60);

    return $deg . "&deg; " . $min . "' " . round($sec, 3) . "\"";
  }

  // Right ascension (celestial longitude) should be representeted in Hours / Minutes / Seconds
  if ($axis == 'lon') {
    $tempma = $dec / 15;
    $vars = explode(".", $tempma);
    $hrs = $vars[0];
    if (isset($vars[1])) {
      $tempma = "0." . $vars[1];
    }
    else {
      $tempma = "0";
    }
    $tempma = $tempma * 60;
    $vars = explode(".", $tempma);
    $min = $vars[0];
    if (isset($vars[1])) {
      $tempma = "0." . $vars[1];
    }
    else {
      $tempma = "0";
    }
    $sec = $tempma * 60;

    return $hrs . "h " . $min . "m " . round($sec, 3) . "s";
  }
}

/**
 * Haversine formula, useful for injecting into an SQL statement. In instances where it isn't possible to pass in variables dynamically (i.e. field
 *   definitions), this function will bake in values directly into the snippet.
 *
 * @param $options
 *   An array of parameters that can be passed along to be injected directly into the SQL snippet. The following array keys are checked...
 *     - origin_latitude
 *     - origin_longitude
 *     - destination_latitude
 *     - destination_longitude
 *     - earth_radius
 *
 * @return
 *   A string suitable for injection into DBTNG. Any option passed into the function will be baked into the string directly. Any variable missing will
 *     be represented as :[variable]. (i.e. :earth_radius).
 */

function geofield_haversine($options = array()) {
  $formula = '( :earth_radius * ACOS( COS( RADIANS(:origin_latitude) ) * COS( RADIANS(:destination_latitude) ) * COS( RADIANS(:destination_longitude) - RADIANS(:origin_longitude) ) + SIN( RADIANS(:origin_latitude) ) * SIN( RADIANS(:destination_latitude) ) ) )';

  foreach ($options as $key => $option) {
    if (is_numeric($option)) {
      $formula = str_replace(':' . $key, $option, $formula);
    }
    else {
      $formula = str_replace(':' . $key, db_escape_field($option), $formula);
    }
  }

  return $formula;
}
